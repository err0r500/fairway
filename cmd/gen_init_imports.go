package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func main() {
	// Configuration
	boundedContext := "" // default
	if len(os.Args) > 1 {
		boundedContext = strings.TrimSpace(os.Args[1])
	}
	outputFile := "init_imports.gen.go"
	packageName := "main"

	// Detect module name from go.mod
	moduleName := getModuleName()
	if moduleName == "" {
		log.Fatal("Could not detect module name from go.mod")
	}

	// Find all Go packages with init functions
	var imports []string

	sliceDirs := []string{"change", "view", "automate"}
	for _, sliceDir := range sliceDirs {
		scanDir := filepath.Join(boundedContext, sliceDir)
		entries, err := os.ReadDir(scanDir)
		if err != nil {
			log.Printf("Warning: skipping %s: %v", scanDir, err)
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				subDir := filepath.Join(scanDir, entry.Name())

				// Check if this directory contains init functions
				if hasInitFunction(subDir) {
					// Create import path
					var importPath string
					if boundedContext == "" {
						importPath = fmt.Sprintf("%s/%s/%s", moduleName, sliceDir, entry.Name())
					} else {
						importPath = fmt.Sprintf("%s/%s/%s/%s", moduleName, boundedContext, sliceDir, entry.Name())
					}

					imports = append(imports, importPath)
					log.Printf("Adding: %s", importPath)
				}
			}
		}
	}

	// Sort imports
	sort.Strings(imports)

	if len(imports) == 0 {
		log.Println("No packages with init() functions found")
		return
	}

	// Generate the file
	if err := generateFile(outputFile, packageName, imports); err != nil {
		log.Fatalf("Error generating file: %v", err)
	}
}

func getModuleName() string {
	content, err := os.ReadFile("go.mod")
	if err != nil {
		return ""
	}

	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "module ") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				return parts[1]
			}
		}
	}
	return ""
}

func hasInitFunction(dir string) bool {
	files, err := os.ReadDir(dir)
	if err != nil {
		return false
	}

	for _, file := range files {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".go") &&
			!strings.HasSuffix(file.Name(), "_test.go") {

			filePath := filepath.Join(dir, file.Name())
			if fileHasInit(filePath) {
				return true
			}
		}
	}
	return false
}

func fileHasInit(filePath string) bool {
	// Parse the Go file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, 0)
	if err != nil {
		log.Printf("Warning: couldn't parse %s: %v", filePath, err)
		return false
	}

	// Look for init function
	for _, decl := range node.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok {
			// Check if it's an init function (no receiver, named "init", no parameters)
			if fn.Recv == nil && fn.Name.Name == "init" && fn.Type.Params.NumFields() == 0 {
				return true
			}
		}
	}

	return false
}

func generateFile(outputFile, packageName string, imports []string) error {
	var code strings.Builder

	code.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	code.WriteString("// This file imports only packages that contain init() functions so they are executed.\n\n")
	code.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	if len(imports) > 0 {
		code.WriteString("import (\n")
		for _, imp := range imports {
			code.WriteString(fmt.Sprintf("\t_ %q\n", imp))
		}
		code.WriteString(")\n")
	}

	// Format the code
	formatted, err := format.Source([]byte(code.String()))
	if err != nil {
		return fmt.Errorf("error formatting code: %w", err)
	}

	// Write to file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		return fmt.Errorf("error writing file: %w", err)
	}

	return nil
}
